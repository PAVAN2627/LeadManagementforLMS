---
phase: 1
plan: 1.1
wave: 1
---

# Plan 1.1: Serverless Environment & Database

## Objective
Establish the foundational environment for Vercel Serverless Functions and MongoDB connectivity. This includes configuring the project structure to support API routes and establishing a reliable database connection with connection pooling.

## Context
- .gsd/SPEC.md (Goal 1: Serverless Architecture)
- .gsd/ARCHITECTURE.md (Data Layer)
- REQ-01: Serverless Setup

## Tasks

<task type="auto">
  <name>Install Backend Dependencies</name>
  <files>package.json</files>
  <action>
    Install core backend dependencies:
    - `mongoose`: MongoDB ODM
    - `dotenv`: Environment variable management
    - `@types/mongoose`: Type definitions
    
    Ensure these are saved as dependencies, not devDependencies.
  </action>
  <verify>npm list mongoose dotenv</verify>
  <done>Dependencies installed and package.json updated.</done>
</task>

<task type="auto">
  <name>Configure Environment</name>
  <files>.env.example, .gitignore</files>
  <action>
    1. Create `.env.example` with:
       - `MONGODB_URI`: Connection string template
       - `JWT_SECRET`: Auth secret template
       - `RESEND_API_KEY`: Email service key template
       - `NODE_ENV`: Environment
    2. Ensure `.env` is listed in `.gitignore`.
  </action>
  <verify>test -f .env.example</verify>
  <done>Environment template exists and secrets are gitignored.</done>
</task>

<task type="auto">
  <name>Setup MongoDB Connection</name>
  <files>src/lib/db.ts</files>
  <action>
    Create `src/lib/db.ts` to handle Mongoose connection.
    - Implement the "cached connection" pattern critical for serverless environments (to avoid creating new connections on every function invocation).
    - Use `global.mongoose` caching strategy.
    
    *Note: Even though API routes will likely live in `/api`, placing shared logic in `src/lib` allows both frontend (if needed) and backend to access types, though typically backend code should be imported from `src` into `api` carefully or `api` should leverage strict imports.*
    
    Actually, to support Vercel Functions in `/api` importing from `src`, we need to ensure tsconfig path aliases work or use relative paths. For clarity, we will assume standard relative imports or configured aliases.
  </action>
  <verify>Check for `mongoose.connect` and caching logic in `src/lib/db.ts`.</verify>
  <done>Database connection module is implemented with caching.</done>
</task>

<task type="auto">
  <name>Configure Vercel Routes</name>
  <files>vercel.json</files>
  <action>
    Create `vercel.json` to configure rewrites.
    - Rewrite `/api/*` to `api/index.js` or ensure Vercel automatically picks up `api/` directory functions.
    - Since we are using Vercel Serverless Functions, standard behavior is that files in `/api` become endpoints.
    - However, for a Vite SPA, we need to ensure non-API routes fall back to `index.html`.
    
    Configuration:
    ```json
    {
      "rewrites": [
        { "source": "/api/(.*)", "destination": "/api/$1" },
        { "source": "/(.*)", "destination": "/index.html" }
      ]
    }
    ```
  </action>
  <verify>test -f vercel.json</verify>
  <done>Vercel configuration handles API and SPA routing.</done>
</task>

## Success Criteria
- [ ] MongoDB connection helper exists with serverless caching.
- [ ] Project has minimal backend dependencies installed.
- [ ] Vercel routing configuration allows for both UI and API.
